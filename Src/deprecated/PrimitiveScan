import numpy as np
import time

from serial import Serial, PARITY_NONE, EIGHTBITS
from Src.robot.SerialMonitor import LDS, StepperHandler, SerialMonitor

class PrimitiveScan:
    
    def __init__(self, stepper_board):
        
        self.LDS = LDS() # Initializes the laser displacement sensor
        self.stepper_board = stepper_board # Initializes the stepper board
    
        # def scanner_points(self):
        self.xc = np.array([]) # Defines arrays for x, y, z and the current axis
        self.yc = np.array([])
        self.zc = np.array([])
        self.ca = np.array([])
    
        self.x_feed = 1500 # Feed rate for x axis motor
        self.x_start = 0 # Start position for x
        self.z_feed = 500 # Feed rate for z axis motor
        self.z_start = 10 # Start position for x
        self.a_feed = 500 # Feed rate for a axis motor (the center platform motor) 
        self.a_start = 0 # Start position for x
    
        self.step = 1 # Initializes how far a step is (1mm)
    
        self.degree = 45 # Degrees we rotate
        self.rotations = 360 / self.degree # Divies up to 8 angles/faces
    
        # MUST START AT SERVO HOME FOR THIS TO WORK
        if Primitive == RectPrism:
            self.edge_1 = 101.5 - val/2  # Take data from inputted edge value and /2 to put you where the edge should be at if centered
            self.edge_2 = 101.5 + val/2  # Same as above but other direction
            self.edge_3 = 101.5 - val_2/2  # Now do the same but for the second face 
            self.edge_4 = 101.5 + val_2/2  # Ditto
            self.offset_1 = 0  # Read in value of LDS and subtract offset based off center for the first face
            self.offset_2 = 0  # Read in value of LDS and subtract offset based off center for the second face
            self.edge_actual_1 = 0 # initalize a value to read the exact value from the LDS into
            self.edge_actual_2 = 0 # same but for the second face

            for h in range(0, 2):  # Set to measure two faces
                    if h = 0
                        self.stepper_board.write_a(0, F=1800) # write the center axis to 0 just to make sure
                    if h = 1
                        self.stepper_board.write_a(90, F=1800) # This will rotate the platform 90 deg for the second face

                self.stepper_board.write_z(self.z_start, self.z_feed) # Aligns the z axis to 0
                self.stepper_board.write_x(self.edge_1 - 5, self.x_feed) # Aligns the x axis past the edge of the object so that the sweep correctly determines the edge
    
                for i in range(self.edge_1 - 5, self.edge_2 + 5): # The range goes from 5mm before the objects centered edge to 5mm after the seond centered edge
                    x_pos = i
                    self.yc = np.append(self.yc, self.LDS.read_distance()) # Reads the y axis as the 
                    if self.yc < 7777 and self.edge_actual_1 == 0:
                        self.xc = np.append(self.xc, x_pos)
                        self.edge_actual_1 = self.xc
                        self.offset_1 = self.edge_1 - self.edge_actual_1
                    elif self.yc > 7777 and self.edge_actual_2 == 0:
                        self.xc = np.append(self.xc, x_pos)
                        self.edge_actual_2 = self.xc
                        self.offset_2 = self.edge_2 - self.edge_actual_2
                    if x_pos == self.edge_2 + 5:
                        self.stepper_board.write_x(self.edge_1, self.x_feed)
                        time.sleep(5)  # Wait for motor to reset to beginning of loop
                    else:
                        self.stepper_board.write_x(x_pos + self.step, self.x_feed)
                        self.stepper_board.read_data()  # change this to just longer than feed rate
            self.stepper_board.write_a(90 * 35.5, F=1800)
            time.sleep(5)
                        
        elif Primitive == Cylinder:
            self.radius_1 = 101.5 - val/2
            self.radius_2 = 101.5 + val/2
            self.offset_1 = 0 # Read in value of LDS and subtract offset based off center for the first side
            self.offset_2 = 0 # Read in value of LDS and subtract offset based off center for the second side
            self.radius_actual_1 = 0
            self.radius_actual_2 = 0
            
            for h in range(0, 2): # Just measure two sides
                self.stepper_board.write_a(90 * 35.5, F=1800)
                self.stepper_board.write_z(self.z_start, self.z_feed)
                self.stepper_board.write_x(self.radius_1 - 5, self.x_feed)
    
                for i in range(self.radius_1 - 5, self.radius_2 + 5):
                    x_pos = i
                    self.xc = np.append(self.xc, x_pos)
                    self.yc = np.append(self.yc, self.LDS.read_distance())  # change this to the adjusted read in value from the sensor
                    
                    if h == 0 and i >= self.radius_2:
                        self.radius_actual_1 = min(self.yc)
                        self.offset_1 = self.radius_1 - self.radius_actual_1
                        self.yc = np.array([])
                    else:
                        self.radius_actual_2 = min(self.yc)
                        self.offset_2 = self.radius_2 - self.radius_actual_2
                        
                    if x_pos == self.radius_2 + 4:
                        time.sleep(1)
                        self.stepper_board.write_x(self.radius_1, self.x_feed)
                        self.stepper_board.read_data()  # wait for response
                        time.sleep(5)  # Wait for motor to reset to beginning of loop
                    else:
                        self.stepper_board.write_x(x_pos + self.step, self.x_feed)
                        self.stepper_board.read_data()  # change this to just longer than feed rate
            self.stepper_board.write_a(90 * 35.5, F=1800)
            time.sleep(5)
            
        elif Primitive == Sphere:
            self.radius = val
            self.radius_1 = 101.5 - val / 2
            self.radius_2 = 101.5 + val / 2
            self.offset_1 = 0  # Read in value of LDS and subtract offset based off center for the first side
            self.offset_2 = 0  # Read in value of LDS and subtract offset based off center for the second side
            self.radius_actual_1 = 0
            self.radius_actual_2 = 0
            for h in range(0, 2):  # Just measure two sides
                self.stepper_board.write_a(90 * 35.5, F=1800)
                self.stepper_board.write_z(self.radius, self.z_feed)
                self.stepper_board.write_x(self.radius_1 - 5, self.x_feed)
    
                for i in range(self.radius_1 - 5, self.radius_2 + 5):
                    x_pos = i
                    self.xc = np.append(self.xc, x_pos)
                    self.yc = np.append(self.yc, self.LDS.read_distance())
                    if h == 0 and i >= self.radius_2:
                        self.radius_actual_1 = min(self.yc)
                        self.offset_1 = self.radius_1 - self.radius_actual_1
                        self.yc = np.array([])
                    else:
                        self.radius_actual_2 = min(self.yc)
                        self.offset_2 = self.radius_2 - self.radius_actual_2
                    if x_pos == self.radius_2 + 4:
                        time.sleep(1)
                        self.stepper_board.write_x(self.radius_1, self.x_feed)
                        self.stepper_board.read_data()  # wait for response
                        time.sleep(5)  # Wait for motor to reset to beginning of loop
                    else:
                        self.stepper_board.write_x(x_pos + self.step, self.x_feed)
                        self.stepper_board.read_data()  # change this to just longer than feed rate
                self.stepper_board.write_a(90 * 35.5, F=1800)
                time.sleep(5)
        else:
            print("Primitive Object scan was not properly called")


